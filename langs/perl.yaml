extension: pl
casing:
  class: pascal_case
  method: camel_case
classes:
  OneString:
    fields:
      length:
        template: "length({{self}})"
    methods:
      substring:
        template: "substr {{self}}, {{start}}, ({{end}} - {{start}})"
      split:
        template: "split({{separator}}, {{self}})"
      get:
        template: "substr {{self}}, {{idx}}, 1"
  OneConsole:
    methods:
      print:
        template: "print {{str}} . \"\\\\n\""
  OneArray:
    fields:
      length:
        template: "scalar({{self}})"
    methods:
      add:
        template: "push {{self}}, {{item}}"
      get:
        template: "{{hackPerlToVar(self)}}[{{index}}]"
      set:
        template: "{{hackPerlToVar(self)}}[{{index}}] = {{value}}"
  OneMap:
    methods:
      keys:
        template: "keys {{self}}"
      values:
        template: "values {{self}}"
      remove:
        template: "delete {{hackPerlToVar(self)}}{{{key}}}"
      hasKey:
        template: "exists {{hackPerlToVar(self)}}{{{key}}}"
      get:
        template: "{{hackPerlToVar(self)}}{{{key}}}"
      set:
        template: "{{hackPerlToVar(self)}}{{{key}}} = {{value}}"
  OneFile:
    methods:
      readText:
        extraArgs: [result]
        template: |-
          open my $fh, '<', {{fn}} or die "Can't open file $!";
          read $fh, my ${{result}}, -s $fh;
          close($fh);
operators:
  OneString + OneString:
    template: "{{gen(left)}} . {{gen(right)}}"
  OneString += OneString:
    template: "{{gen(left)}} .= {{gen(right)}}"
templates:
  testGenerator: |-
    package Program;
    my $c = new {{class}}();
    $c->{{method}}();

  main: |-
    use strict;
    use warnings;

    {{for class in classes|sep=\n\n}}
      package {{class.name}};

      sub new
      {
          my $class = shift;
          my $self = {};
          bless $self, $class;
          return $self;
      }

      {{for field in class.fields|sep=\n}}
        {{if field.static}}
          our ${{field.name}}{{if field.initializer}}\ = {{gen(field.initializer)}}{{/if}};
        {{/if}}
      {{/for}}

      {{for method in class.methods|sep=\n\n}}
        sub {{method.name}} {
            my ( $self{{for param in method.parameters}}, ${{param.name}}{{/for}} ) = @_;
            {{genBody(method.body)}}
        }
      {{/for}}
    {{/for}}

  genBody:
    args:
      - name: body
    template: |-
      {{for statement in body.statements|sep=\n}}
        {{statement.leadingTrivia2}}{{gen(statement)}}
      {{/for}}

  genArgs:
    args:
      - name: method
    template: |-
      {{for param in method.parameters|sep=", "}}
        {{param.type}} {{param.name}}
      {{/for}}
  genParams:
    args:
      - name: params
    template: |-
      {{for param in params|sep=", " inline}}
        {{gen(param)}}
      {{/for}}
  genVar:
    args:
      - name: itemVar
    template: "my {{varName(itemVar)}} = {{gen(itemVar.initializer)}}"

  varName:
    args:
      - name: item
      - name: asVar
    template: "{{if item.type.isOneMap && !asVar}}%{{else}}{{if item.type.isOneArray && !asVar}}@{{else}}${{/if}}{{/if}}{{item.name}}"
expressions:
  call: |-
    {{gen(expr.method)}}(
      {{for arg in expr.arguments|sep=", " inline}}
        {{gen(arg)}}
      {{/for}}
    )
  propertyAccess: "{{gen(expr.object)}}->{{gen(expr.propertyName)}}"
  identifier: "${{expr.text}}"
  stringLiteral: "\"{{expr.value}}\""
  nullLiteral: "undef" # ???
  return: "return {{gen(expr.expression)}};"
  binary: "{{gen(expr.left)}} {{expr.operator}} {{gen(expr.right)}}"
  postfix: "{{gen(expr.operand)}}{{expr.operator}}"
  prefix: "{{expr.operator}}{{gen(expr.operand)}}"
  parenthesized: "({{gen(expr.expression)}})"
  numericLiteral: "{{expr.value}}"
  variableDeclaration: "{{genVar(expr)}};"
  new: "new {{gen(expr.class)}}({{genParams(expr.arguments)}})"
  classReference: "{{expr.classRef.name}}"
  arrayLiteral: "({{genParams(expr.items)}})"
  mapLiteral: |- 
    (
      {{for prop in expr.properties|sep="\n"}}
        {{prop.name}} => {{gen(prop.initializer)}},
      {{/for}}
    )
  expressionStatement: "{{gen(expr.expression)}};"
  instanceMethod: "{{gen(expr.thisExpr)}}->{{expr.methodRef.name}}"
  staticMethod: "{{expr.methodRef.classRef.name}}::{{expr.methodRef.name}}"
  localVar: "{{varName(expr.varRef, args[0])}}"
  methodArgument: "{{varName(expr.varRef)}}"
  instanceField: "{{gen(expr.thisExpr)}}->{{expr.varRef.name}}"
  staticField: "${{gen(expr.thisExpr)}}::{{expr.varRef.name}}"
  trueLiteral: "1"
  falseLiteral: "0"
  elementAccess: "{{gen(expr.object, true)}}{{{gen(expr.elementExpr)}}}"
  thisReference: $self
  foreach: |-
    foreach my ${{expr.itemVariable.name}} ({{gen(expr.items)}}) {
        {{genBody(expr.body)}}
    }
  for: |-
    for ({{genVar(expr.itemVariable)}}; {{gen(expr.condition)}}; {{gen(expr.incrementor)}}) {
        {{genBody(expr.body)}}
    }
  if: |-
    if ({{gen(expr.condition)}}) {
        {{genBody(expr.then)}}
    }
    {{if expr.else|inline}}
      {{if isIfBlock(expr.else)}}
        \ els{{genBody(expr.else)}}
      {{else}}
        \ else {
            {{genBody(expr.else)}}
        }
      {{/if}}
    {{/if}}
