extension: cs
casing:
  class: pascal_case
  method: pascal_case
  variable: camel_case
  field: pascal_case
  property: pascal_case
primitiveTypes:
  void: void
  any: object
classes:
  OneString:
    type: string
    fields:
      length:
        template: "{{self}}.Length"
    methods:
      substring:
        template: "{{self}}.Substring({{start}}, {{end}} - {{start}})"
      split:
        template: "{{self}}.Split(new[]{ {{separator}} }, StringSplitOptions.None)"
      get:
        template: "{{self}}.Substring({{idx}}, 1)"
  OneNumber:
    type: int
  OneBoolean:
    type: bool
  OneConsole:
    methods:
      print:
        includes: [System]
        template: "Console.WriteLine({{str}})"
  OneArray:
    type: "List<{{typeArgs[0]}}>"
    includes: [System.Collections.Generic]
    fields:
      length:
        template: "{{self}}.Count"
    methods:
      add: 
        template: "{{self}}.Add({{item}})"
      get: 
        template: "{{self}}[{{index}}]"
      set: 
        template: "{{self}}[{{index}}] = {{value}}"
  OneMap:
    includes: [System.Linq]
    methods:
      keys: 
        template: "{{self}}.Keys.ToArray()"
      values: 
        template: "{{self}}.Values.ToArray()"
      remove: 
        template: "{{self}}.Remove({{key}})"
      hasKey: 
        template: "{{self}}.ContainsKey({{key}})"
      get: 
        template: "{{self}}[{{key}}]"
      set: 
        template: "{{self}}[{{key}}] = {{value}}"
  OneFile:
    includes: [System.IO]
    methods:
      readText:
        template: "File.ReadAllText({{fn}})"
templates:
  testGenerator: |-
    public class Program
    {
        static public void Main()
        {
            new {{class}}().{{method}}();
        }
    }

  main: |-
    {{for inc in includes|sep=\n}}
      using {{inc}};
    {{/for}}

    {{for class in classes|sep=\n\n}}
      public class {{class.name}}
      {
          {{for field in class.fields|sep=\n}}
            {{field.visibility}}\ {{if field.static}}static {{/if}}{{field.type}} {{field.name}}{{if field.initializer}}\ = {{gen(field.initializer)}}{{/if}};
          {{/for}}

          {{if class.constructor}}
            public {{class.name}}({{genArgs(class.constructor)}})
            {
                {{genBody(class.constructor.body)}}
            }
          {{/if}}

          {{for method in class.methods|sep=\n\n}}
            {{method.visibility}}\ {{if method.static}}static {{/if}}{{method.returnType}} {{method.name}}({{genArgs(method)}})
            {
                {{genBody(method.body)}}
            }
          {{/for}}
      }
    {{/for}}
  genBody:
    args:
      - name: body
    template: |-
      {{for statement in body.statements|sep=\n}}
        {{statement.leadingTrivia}}{{gen(statement)}}
      {{/for}}
  genArgs:
    args:
      - name: method
    template: |-
      {{for param in method.parameters|sep=", "}}
        {{param.type}} {{param.name}}
      {{/for}}
  genParams:
    args:
      - name: params
    template: |-
      {{for param in params|sep=", " inline}}
        {{gen(param)}}
      {{/for}}
  genVar:
    args:
      - name: itemVar
    template: "{{if itemVar.isUnused}}// UNUSED: {{/if}}var {{itemVar.name}} = {{gen(itemVar.initializer)}}"
expressions:
  call: "{{gen(expr.method)}}({{genParams(expr.arguments)}})"
  propertyAccess: "{{gen(expr.object)}}.{{gen(expr.propertyName)}}"
  identifier: "{{expr.text}}"
  stringLiteral: "{{expr.escapedText}}"
  numericLiteral: "{{expr.value}}"
  nullLiteral: "null"
  return: "return {{gen(expr.expression)}};"
  binary: "{{gen(expr.left)}} {{expr.operator}} {{gen(expr.right)}}"
  postfix: "{{gen(expr.operand)}}{{expr.operator}}"
  prefix: "{{expr.operator}}{{gen(expr.operand)}}"
  parenthesized: "({{gen(expr.expression)}})"
  variableDeclaration: "{{genVar(expr)}};"
  new: "new {{gen(expr.class)}}({{genParams(expr.arguments)}})"
  classReference: "{{expr.classRef.name}}"
  arrayLiteral: "new List<{{expr.typeArgs[0]}}> { {{genParams(expr.items)}} }"
  mapLiteral: |- 
    new Dictionary<{{expr.typeArgs[0]}}, {{expr.typeArgs[1]}}>
    {
      {{for prop in expr.properties|sep=",\n"}}
        { "{{prop.name}}", {{gen(prop.initializer)}} }
      {{/for}}
    }
  expressionStatement: "{{gen(expr.expression)}};"
  instanceMethod: "{{gen(expr.thisExpr)}}.{{expr.methodRef.name}}"
  staticMethod: "{{expr.methodRef.classRef.name}}.{{expr.methodRef.name}}"
  localVar: "{{expr.varRef.name}}"
  methodArgument: "{{expr.varRef.name}}"
  instanceField: "{{gen(expr.thisExpr)}}.{{expr.varRef.name}}"
  staticField: "{{gen(expr.thisExpr)}}.{{expr.varRef.name}}"
  falseLiteral: "false"
  trueLiteral: "true"
  elementAccess: "{{gen(expr.object)}}[{{gen(expr.elementExpr)}}]"
  thisReference: this
  conditional: "{{gen(expr.condition)}} ? {{gen(expr.whenTrue)}} : {{gen(expr.whenFalse)}}"
  break: break;
  foreach: |-
    foreach (var {{expr.itemVariable.name}} in {{gen(expr.items)}})
    {
        {{genBody(expr.body)}}
    }
  for: |-
    for ({{genVar(expr.itemVariable)}}; {{gen(expr.condition)}}; {{gen(expr.incrementor)}})
    {
        {{genBody(expr.body)}}
    }
  while: |-
    while ({{gen(expr.condition)}})
    {
        {{genBody(expr.body)}}
    }
  if: |-
    if ({{gen(expr.condition)}})
    {
        {{genBody(expr.then)}}
    }
    {{if expr.else}}
      {{if isIfBlock(expr.else)}}
        else\ {{genBody(expr.else)|inline}}
      {{else}}
        else
        {
            {{genBody(expr.else)}}
        }
      {{/if}}
    {{/if}}
