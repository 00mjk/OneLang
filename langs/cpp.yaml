extension: cpp
casing:
  class: pascal_case
  method: camel_case
primitiveTypes:
  void: void
classes:
  OneString:
    type: std::string
    fields:
      length:
        template: "{{self}}.size()"
    methods:
      substring:
        template: "{{self}}.substr({{start}}, {{end}} - {{start}})"
      split:
        template: "OneStringHelper::split({{self}}, {{separator}})"
      get:
        template: "{{self}}.substr({{idx}}, 1)"
  OneNumber:
    type: int
  OneBoolean:
    type: bool
  OneArray:
    includes: [vector]
    fields:
      length: 
        template: "{{self}}->size()"
    methods:
      add: 
        template: "{{self}}->push_back({{item}})"
      get: 
        template: "{{self}}->at({{index}})"
      set: 
        template: "(*{{self}})[{{index}}] = {{value}}"
  OneMap:
    includes: [map]
    methods:
      keys: 
        template: "OneMapHelper::keys(*{{self}})"
      values: 
        template: "OneMapHelper::values(*{{self}})"
      remove: 
        template: "{{self}}->erase({{key}})"
      hasKey: 
        template: "{{self}}->find({{key}}) != {{self}}->end()"
      get: 
        template: "(*{{self}})[{{key}}]"
      set: 
        template: "(*{{self}})[{{key}}] = {{value}}"
  OneConsole:
    includes: [iostream]
    methods:
      print:
        template: "std::cout << {{str}} << std::endl"
includes: [memory, fstream, vector, map]
templates:
  testGenerator: |-
    int main()
    {
        {{class}} c;
        c.{{method}}();
        return 0;
    }

  main: |-
    {{for inc in includes|sep=\n}}
      #include <{{inc}}>
    {{/for}}

    class OneMapHelper {
      public:
        template<typename K, typename V> static std::shared_ptr<std::vector<K>> keys(const std::map<K,V>& map) {
            std::vector<K> result;
            for(auto it = map.begin(); it != map.end(); ++it)
                result.push_back(it->first);
            return std::make_shared<std::vector<K>>(result);
        }

        template<typename K, typename V> static std::shared_ptr<std::vector<V>> values(const std::map<K,V>& map) {
            std::vector<V> result;
            for(auto it = map.begin(); it != map.end(); ++it)
                result.push_back(it->second);
            return std::make_shared<std::vector<V>>(result);
        }
    };

    class OneStringHelper {
      public:
        static std::shared_ptr<std::vector<std::string>> split(const std::string& str, const std::string& delim)
        {
            std::vector<std::string> tokens;
            
            size_t prev = 0, pos = 0;
            do
            {
                pos = str.find(delim, prev);
                if (pos == std::string::npos) pos = str.length();
                std::string token = str.substr(prev, pos - prev);
                tokens.push_back(token);
                prev = pos + delim.length();
            }
            while (pos < str.length() && prev < str.length());

            return std::make_shared<std::vector<std::string>>(tokens);
        }
    };

    class OneFile {
      public:
        static std::string readText(const std::string& path)
        {
          std::ifstream file(path);
          std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
          return content;
        }
    };

    {{for class in classes|sep=\n\n}}
      class {{class.name}} {
        public:
          {{genFields(class.publicFields)}}
          {{genMethods(class.publicMethods)}}

        private:
          {{genFields(class.privateFields)}}
          {{genMethods(class.privateMethods)}}
      };

      {{for field in class.fields|sep=\n}}
        {{if field.static && field.initializer}}
          {{getType(field)}} {{class.name}}::{{field.name}} = {{gen(field.initializer)}};
        {{/if}}
      {{/for}}
    {{/for}}
  genFields:
    args:
      - name: fields
    template: |-
      {{for field in fields|sep=\n}}
        {{if field.static}}static {{/if}}{{getType(field)}} {{field.name}};
      {{/for}}
  getType:
    args:
      - name: item
    template: "{{item.type}}{{if item.typeInfo.isClass && !item.typeInfo.isString}}*{{/if}}"

  getTypeX:
    args:
      - name: type
    template: "{{typeName(type)}}{{if type.isClass && !type.isString}}*{{/if}}"

  genMethods:
    args:
      - name: methods
    template: |-
      {{for method in methods|sep=\n\n}}
        {{method.returnType}} {{method.name}}({{genArgs(method)}}) {
            {{genBody(method.body)}}
        }
      {{/for}}

  genBody:
    args:
      - name: body
    template: |-
      {{for statement in body.statements|sep=\n}}
        {{statement.leadingTrivia}}{{gen(statement)}}
      {{/for}}

  genArgs:
    args:
      - name: method
    template: |-
      {{for param in method.parameters|sep=", "}}
        {{param.type}} {{param.name}}
      {{/for}}
  genParams:
    args:
      - name: params
    template: |-
      {{for param in params|sep=", " inline}}
        {{gen(param)}}
      {{/for}}
  genVar:
    args:
      - name: itemVar
    template: |-
      {{if itemVar.type.isNumber}}int{{else}}auto{{/if}} {{itemVar.name}} = {{gen(itemVar.initializer)}}

expressions:
  call: |-
    {{gen(expr.method)}}(
      {{for arg in expr.arguments|sep=", " inline}}
        {{gen(arg)}}
      {{/for}}
    )
  propertyAccess: "{{gen(expr.object)}}->{{gen(expr.propertyName)}}"
  identifier: "{{expr.text}}"
  stringLiteral: "std::string(\"{{expr.value}}\")"
  return: "return {{gen(expr.expression)}};"
  binary: "{{gen(expr.left)}} {{expr.operator}} {{gen(expr.right)}}"
  postfix: "{{gen(expr.operand)}}{{expr.operator}}"
  prefix: "{{expr.operator}}{{gen(expr.operand)}}"
  parenthesized: "({{gen(expr.expression)}})"
  numericLiteral: "{{expr.value}}"
  nullLiteral: "nullptr"
  variableDeclaration: "{{genVar(expr)}};"
  new: "std::make_shared<{{gen(expr.class)}}>({{genParams(expr.arguments)}})"
  classReference: "{{expr.classRef.name}}"
  arrayLiteral: "std::make_shared<std::vector<{{expr.typeArgs[0]}}>>(std::vector<{{expr.typeArgs[0]}}> { {{genParams(expr.items)}} })"
  mapLiteral: |- 
    std::make_shared<std::map<{{expr.typeArgs[0]}}, {{expr.typeArgs[1]}}>>(std::map<{{expr.typeArgs[0]}}, {{expr.typeArgs[1]}}> {
      {{for prop in expr.properties|sep=",\n"}}
        { "{{prop.name}}", {{gen(prop.initializer)}} }
      {{/for}}
    })
  expressionStatement: "{{gen(expr.expression)}};"
  instanceMethod: "{{gen(expr.thisExpr)}}->{{expr.methodRef.name}}"
  staticMethod: "{{expr.methodRef.classRef.name}}::{{expr.methodRef.name}}"
  localVar: "{{expr.varRef.name}}"
  methodArgument: "{{expr.varRef.name}}"
  instanceField: "{{gen(expr.thisExpr)}}->{{expr.varRef.name}}"
  staticField: "{{gen(expr.thisExpr)}}::{{expr.varRef.name}}"
  falseLiteral: "false"
  trueLiteral: "true"
  elementAccess: "(*{{gen(expr.object)}})[{{gen(expr.elementExpr)}}]"
  thisReference: this
  foreach: |-
    for (auto it = {{gen(expr.items)}}->begin(); it != {{gen(expr.items)}}->end(); ++it) {
        auto {{expr.itemVariable.name}} = *it;
        {{genBody(expr.body)}}
    }
  for: |-
    for ({{genVar(expr.itemVariable)}}; {{gen(expr.condition)}}; {{gen(expr.incrementor)}}) {
        {{genBody(expr.body)}}
    }
  if: |-
    if ({{gen(expr.condition)}}) {
        {{genBody(expr.then)}}
    }
    {{if expr.else|inline}}
      {{if isIfBlock(expr.else)}}
        \ else\ {{genBody(expr.else)|inline}}
      {{else}}
        \ else {
            {{genBody(expr.else)}}
        }
      {{/if}}
    {{/if}}